# 1.4a Features of Proposed Solution

## Mechanics

### Controls for movement

I have decided to use the WSAD keys for the player to move their car about. These are used in most PC games, therefore many players will be familiar with these controls.&#x20;

* W: Move the car forward.
* S: Reverse the car.
* A: Turn the car left.
* D: Turn the car right.

I will attempt to simulate the physics of a real car in the game. To do this, I will add speed and acceleration properties to the car sprite. The speed will be set to 0 at the start and revert back to this if the player stops moving it. While the player presses down W to move forward, the acceleration will continually be added to the speed. Similarly, pressing down S to reverse will continually deduct the acceleration from the speed. This gives driving the car a more realistic feel.

### Health system

The player will start the game with ten health points, each one represented by a heart. Health points can be lost through being attacked by monsters and being hit by explosions caused by missiles such as TNT and fireballs. They can be replenished through obtaining a Potion of Regeneration or Healing. The health points the player has will be displayed as red hearts, while the ones it has lost will be displayed as dark grey.&#x20;

If the player runs out of healthpoints, the screen will gradually fade dark and after a few seconds begin to brighten again. The total process will take ten seconds and the player will be unable to move their car or interact with the game for the whole time, which could have a significant impact on their position. After "dying", the player will have all their health points restored.

### Side-scrolling

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (2) (1) (1).png" alt=""><figcaption><p>In this Flappy Bird game, the player's character is always on the left side of the screen</p></figcaption></figure>

A common characteristic of 2D games is for the camera to continually follow the player so that they are in a certain position of the screen, often the far left or centre. This means the player will never lose track of their character in the game no matter where they go on the map. In my game, whenever the player's coordinates are updated, the camera will adjust so that the road is always in the middle of the screen and the player's car is near the bottom.

<figure><img src="../.gitbook/assets/image (14).png" alt=""><figcaption><p>Drawing of how the road and car will be positioned on the screen</p></figcaption></figure>

## User Interface&#x20;

### Title screen

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption><p>Drawing of title screen layout</p></figcaption></figure>

My game's title screen will be simple. At the top middle of the screen it will have the title of the game. In the centre I will have play and sign out buttons, and text underneath displaying the player's username.&#x20;

The game will only be playable to those signed in. Those not signed in will be shown a different screen with a brief explanation they must be signed in to play and a button which redirects them to the login form.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



My game's title screen will be simple and its buttons will depend on whether the player is signed in. For those signed in, it will include buttons to join multiplayer games and access the leaderboard, while those signed out will be limited to singleplayer mode. The furthest down button will either say "Sign In" or "Sign Out" depending on if the player is signed in or not. If the player is signed in, their username will be displayed below the sign out button.

### Multiplayer

<figure><img src="../.gitbook/assets/multiplayer.png" alt=""><figcaption></figcaption></figure>

My game will be an online multiplayer game. Players can create a room which will generate a code which up to four more people can use to join the room. When any player clicks to start the game, all players will move onto the gameplay itself. Each player will be assigned a car which they control with WSAD. All updates of the player's movement will be broadcasted to other players in the room.

### Leaderboard

The leaderboard will sort the list of players by their record time in ascending order, so that the shortest times are shown first. The top 50 times will be accessible in the leaderboard and the player will be able to see their own position no matter where they are in the leaderboard. The leaderboard will only be accessible to logged in users and only singleplayer records will count, in order for it to be fair.

## Chests

Chests will be scattered across the race map. When a player collides with a chest, a power-up is randomly selected and given to the player. The player can activate the power-up by pressing shift.

I plan on including the following power-ups:

* Potion of Speed: Increases player speed by 1.5x for 10 seconds.
* Potion of Regeneration: Replenishes 1 health point every second for 10 seconds.
* Potion of Healing: Replenishes 3 health points instantly upon usage.
* TNT: Placed behind the player using it. When other players come within close range of the TNT, it explodes, dealing 5 health points of damage.
* Fireball: Allows the player to click anywhere in front of them to fire it. If the fireball hits another player, they lose 3 health points.
* Monster Army: Spawns up to five monsters (zombies, skeletons, creepers) who chase after other players on the race track. The army disappears after 30 seconds.

The power-up the player currently has waiting will show in a box in the top left corner of the screen.

<figure><img src="../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

## Enemies

My game will have three non-player enemies: zombie, skeleton, and creeper, based off the monsters from Minecraft. Players will encounter these enemies when another player uses the "Monster Army" power-up obtained from a chest. Unlike in Minecraft, the goal is not to fight enemies, rather it is to avoid them because they only appear for 30 seconds. Monsters do not attack the player that spawned them through the Monster Army power-up.

* Zombie: Runs after passing players attempting to hit them close up. Being hit inflicts 1 point of damage.
* Skeleton: Shoots arrows after passing players. Being hit inflicts 1 point of damage.
* Creeper: Explodes when coming within close proximity of a player. Being in this explosion inflicts 4 points of damage.

### Player detection

<figure><img src="../.gitbook/assets/image (35).png" alt=""><figcaption></figcaption></figure>

Monsters will attempt to attack all players except the player that spawned them. They will continually check for players entering within a certain radius of them.&#x20;

Once a player is detected, the monster needs to find out how to get to the player, or in the case of the skeleton, where to shoot its arrows. The game will imagine a triangle: the opposite side will be the distance between the monster's Y co-ordinate and the player's Y co-ordinate, while the adjacent will be the distance between the two X co-ordinates. These two distances will be used along with tan to work out the angle between the opposite and the hypotenuse, which is a single straight line between the monster and the player. Finally, the game will use sin and cos functions to calculate the speed at which the monster must move at to get to the player.&#x20;

## Levels

My game will have four levels similar to Mario Kart cups having four races. They will mostly stay the same in terms of features and difficulty but take place in different environments based on Minecraft biomes.&#x20;

* Level 1: Set in plains biome. The road will be made of dirt and the surroundings will be grass and trees.
* Level 2: Set in desert biome. The road will be sandstone and the surroundings will be grass and cacti.
* Level 3: Set in mesa biome.
* Level 4: Set on mountain.

### Map Generation

When a player creates a new room, the server will generate maps for each level with a specified number of tiles horizontally and vertically. The map will be split into two separate sections, the road and the environment. The road will comprise five blocks in the horizontal middle of the map because up to five players can join a room. Whatever block is going to be the road for each level will be present in the road section alongside chests, while the surrounding blocks such as grass (and trees if I have time to add them at the end) will be on each side of the road as the environment.

## Limitations

### Gamepad support

At the start, I wanted to add support for use of gamepads such as Xbox controllers. Kaboom.js actually supports this by utilising JavaScript's Gamepad API. However, since joining a multiplayer game requires entering in a code, this means I would have to write an on-screen keyboard that works with Kaboom.js. This would take too much time for my project and therefore I have decided to stick with keyboard.

### AI cars for rooms with less than five players

I did want to include this, but I decided adding all the relevant sensors and behaviours and writing the neutral network would take too much time and overcomplicate the project.
