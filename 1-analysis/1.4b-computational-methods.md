# 1.4b Computational Methods

## Thinking Abstractly and Visualisation

Abstraction means the removal of unnecessary information in a problem to focus only on the important information. It is useful in programming because it helps avoid over-complicating the solution and allows the developer to focus on the high-level design of the program.

My game will use abstraction in the following ways:

* Graphics: While I would like to make detailed graphics, I will start with basic graphics so I can focus on programming. If I still have time after completing my game, I will improve the graphics.
* Leaderboard + Login: Although the game itself will be written in Kaboom.js, these sections will be separate HTML pages so I can use the HTML elements. I won't add CSS to make the page look tidier and more professional until I've finished development, just in case I don't have enough time.
* Enemy detection of player: When a player comes within specified range of an enemy, my game will compare the player x coordinate to that enemy's x coordinate to determine which direction the enemy will move in to pursue the player. This algorithm is easy to implement and improves the intelligence of enemies in tracking their targets.

## Thinking Ahead

Thinking ahead is important in programming because it provides the developer or developers with a clear idea of what they want the final product to look like. I will think about what tasks I must carry out and in what order I will perform them for my final solution to look how I envision it.&#x20;

For example, I know my game will be written in Javascript, playable in the web browser, and that I will use Kaboom.js to simplify the development of the gameplay element. Additionally, my game will have five levels with increasing difficulty as the player progresses and a boss fight at the end. Furthermore, I want my game to have a leaderboard, so I have chosen the SQLite3 module for Node.js to easily read and write from a database that stores players' quickest times. Because Node.js is server-based, I will need to find a suitable hosting provider so that people can access the game. This hosting provider should be reliable, well-known, and be free or a reasonable cost for the scale of this project.

## Thinking Procedurally and Decomposition

Decomposition is the process of breaking down a complex problem into smaller, more manageable problems. It is useful because it simplifies development of the solution and makes it easier to apply changes. I will focus on one section of my game at a time and finish a section before starting on another.&#x20;

My project will use decomposition and procedural thinking to divide development into several stages. Since my game will be full-stack, I will start with developing the back-end so when I start developing the front-end, i can test features that rely on the back-end such as multiplayer and leaderboard.

Additionally, I will bundle interactive elements of the game such as movement and activating weapon into functions so that they can be called whenever the relevant keyboard input is pressed without having to copy and paste chunks of code. This makes it easy to modify and fix bugs.

## Thinking Logically

My game should allow the player to make decisions when multiple options are presented to them. To do this, it must be prepared for any possible decisions the player might make when playing.

### Title screen

* My game will not require the player login to merely play, but will require it in order to access the leaderboard, have their time record saved, and play multiplayer. If the player chooses not to login, the title screen will not have multiplayer or view leaderboard buttons.

### Login/Sign Up screen

* The player may enter invalid credentials when logging in, so the login should be prepared for this happening and be able to inform the player in a user-friendly way.
* The player may choose a username that has already been taken when signing up, so the registration should be prepared for this possibility and inform the player.&#x20;

### Gameplay

* My game will continually check for keyboard input from the player and carry out corresponding actions, for example to move or change direction. It must also be prepared for the possibility that the player may press a key that does not have a corresponding action and ignore it.
* When the player activates their weapon, my game must be prepared for them to attempt to use it on a target that is out of the maximum range of that weapon and be able to indicate this to the player. I plan for my game to display an indicator at the top centre of the screen for whether the target is in range.

### Multiplayer

* If playing multiplayer, my game should be prepared for the possibility of the session host quitting. If that happens, the host role will be transferred to the next earliest player to have joined.
* Each multiplayer session will be given an 8 character-long code of letters and numbers to help the back-end distinguish it from others. My game should be prepared for a code being generated that is already in use by another session and to continue generating until a unique code is found.

## Thinking Concurrently

My game will need to perform multiple tasks simultaneously by breaking them down into sub-tasks. Here are some examples:

* All enemies in the level must continually check if the player is within a specific range of them even while other tasks are taking place, such as checking for keys or the player activating their selected weapon.&#x20;
* In multiplayer mode, the Node.js server must be able to handle all requests from different sessions at once. For example, two multiplayer sessions could be running at the same time, so the server should be able to distinguish between the two sessions in its responses to prevent confusion.
