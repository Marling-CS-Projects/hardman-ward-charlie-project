# 1.4b Computational Methods

## The need for computational methods

* Physics: Detect collision between sprites and act accordingly, for example the player colliding with an enemy sprite would lead to the player losing health, and an arrow colliding with an enemy sprite would lead to that enemy losing health. Simulate gravity.
* Progressive difficulty: As my game progresses, I want it to become more challenging for the player. Difficulty in my game will increase as the player's level increases. The effects will include monsters spawning more frequently, being faster, and doing more attack damage.&#x20;
* Cross-platform support: I want my game to be compatible with both keyboard and touchscreen devices. In order to do this, my game will check if a touchscreen is in use and if so, add buttons to the screen to be used instead of a keyboard.
* Controls: For keyboard users, the computer would need to constantly check for keys being pressed and carry out the relevant action, while for touchscreen users actions would be carried out when the player presses the on-screen buttons.

## Thinking Abstractly and Visualisation

Abstraction means the simplification of complex problems by focusing only on the relevant information.

## Thinking Ahead



## Thinking Procedurally and Decomposition

Decomposition is the breaking down of a complex problem into smaller and more manageable problems. This makes development easier as it allows focusing on one part of a problem at a time. I will make sure I only focus on one section of the game at a time. Additionally, I can put frequently used code and instructions into subroutines so I can call them when needed without having to repeat code on a large scale.

My project will be full-stack, meaning it uses both front-end (client-side) and back-end (server-side) components. I have decided to develop the back-end first before the front-end because the back-end is responsible for reading from and writing to the database, where player information is stored. After I've finished developing the back-end, I can focus on developing the front-end using Kaboom.js.

I will break my project down into the following parts:

* Sign In/Sign Up
* Leaderboard
* Level generation
* Setup player and controls
* Timer
* Side-scrolling
* Selection and use of weapon
* Enemy behaviour
* Death of player
* Level progression
* Completion of game

## Thinking Logically

My game must be prepared for whatever decisions the player makes and how to respond from there. For example, killing enemies regenerates health, but if the player has full health then it should not have any effect. Another example is if a player gets far enough away from an enemy, then that enemy should stop pursuing the player.&#x20;

During level generation, my game should spawn enemies in groups of 1 to a defined amount. My game should make sure there is reasonable space between groups to prevent overcrowding. This can be done through a variable which counts how many spaces since the last enemy and is compared to a defined amount when deciding whether to spawn a group.

As the level increases, my game should become harder. This can be done by increasing the maximum size of groups of enemy sprites; decreasing the minimum space between groups of enemies; and increasing the damage they inflict on collision with the player.&#x20;

## Thinking Concurrently

