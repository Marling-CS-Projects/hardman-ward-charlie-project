# 1.4b Computational Methods

## Thinking Abstractly and Visualisation

Abstraction means the removal of unnecessary information in a problem to focus only on the important information. It is useful in programming because it helps avoid over-complicating the solution and allows the developer to focus on the high-level design of the program.

My game will use abstraction in the following ways:

* Graphics: While I would like to make detailed graphics, I will start with basic graphics so I can focus on programming. If I still have time after completing my game, I will improve the graphics.
* Leaderboard + Login: Although the game itself will be written in Kaboom.js, these sections will be separate HTML pages so I can use the HTML elements. I won't add CSS to make the page look tidier and more professional until I've finished development, just in case I don't have enough time.
* Enemy detection of player: When a player comes within specified range of an enemy, my game will compare the player x coordinate to that enemy's x coordinate to determine which direction the enemy will move in to pursue the player. This algorithm is easy to implement and improves the intelligence of enemies in tracking their targets.

## Thinking Ahead

Thinking ahead is important in programming because it provides the developer or developers with a clear idea of what they want the final product to look like. I will think about what tasks I must carry out and in what order I will perform them for my final solution to look how I envision it.&#x20;

For example, I know my game will be written in Javascript, playable in the web browser, and that I will use Kaboom.js to simplify the development of the gameplay element. Additionally, my game will have five levels with increasing difficulty as the player progresses and a boss fight at the end. Furthermore, I want my game to have a leaderboard, so I have chosen the SQLite3 module for Node.js to easily read and write from a database that stores players' quickest times. Because Node.js is server-based, I will need to find a suitable hosting provider so that people can access the game. This hosting provider should be reliable, well-known, and be free or a reasonable cost for the scale of this project.

## Thinking Procedurally and Decomposition

Decomposition is the process of breaking down a complex problem into smaller, more manageable problems. It is useful because it simplifies development of the solution and makes it easier to apply changes. I will focus on one section of my game at a time and finish a section before starting on another. Since my game will be full-stack, I will develop the back-end first so when I start development of the front-end I can test features reliant on the back-end such as multiplayer and the leaderboard. Additionally, I will bundle interactive elements of my game such as movement into functions because each interactive element will have two listeners for touch and keyboard input; calling functions would simplify the code.

## Thinking Logically

My game should allow the player to make decisions when multiple options are presented to them. To do this, it must be prepared for any possible decisions the player might make when playing.

### Title screen

* My game will not require the player login to merely play, but will require it in order to access the leaderboard, have their time record saved, and play multiplayer. If the player chooses not to login, the title screen will not have multiplayer or view leaderboard buttons.

### Login/Sign Up screen

* The player may enter invalid credentials when logging in, so the login should be prepared for this happening and be able to inform the player in a user-friendly way.
* The player may choose a username that has already been taken when signing up, so the registration should be prepared for this possibility and inform the player.&#x20;

### Gameplay

* My game will continually check for keyboard input from the player and carry out corresponding actions, for example to move or change direction. It must also be prepared for the possibility that the player may press a key that does not have a corresponding action and ignore it.
* My game will check if the player is using a touchscreen and if they are, it must render visual buttons on the left hand side of the screen for the player to use for movement instead of a keyboard. It will then continually check if they are pressed and carry out the corresponding action.
* When the player attempts to activate a weapon, my game must be prepared for them to attempt to use it on a target that is out of the maximum range of that weapon and be able to indicate this to the player. I plan for my game to display an indicator at the top centre of the screen for whether the target is in range.

### Multiplayer

* If playing multiplayer, my game should be prepared for the possibility of the session host quitting. If that happens, the host role will be transferred to the next earliest player to have joined.
* Each multiplayer session will be given an 8 character-long code of letters and numbers to help the back-end distinguish it from others. My game should be prepared for a code being generated that is already in use by another session and to continue generating until a unique code is found.

## Thinking Concurrently

